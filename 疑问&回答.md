1.轻节点和全节点作用的区别？

为什么 “在比特币网络中，大多数节点都是轻节点。如果只是想进⾏转账操作，不需要挖矿，就无需运⾏一个全节点。”





2.女巫攻击



3.比特币花两次攻击

    总结一下：
    
    (1) 大部分情况下比特币的UTXO机制和区块链的共识机制都能有效应对双花攻击；
    
    (2) 对于小额支付，等待一个确认通常就可以认为安全了，但是对于大额支付，需要等6个确认才能大概率的认为安全，否则如果攻击者掌握很强算力，有可能构造累计工作量超过当前主链的攻击链导致双花成功。




    在传统的交易中，因为有银行这样的中心化机构，所以是不会存在双花问题的：每一笔支付都将从你的银行账户中扣除相应的资金，所有的明细在银行都有记录。但是在比特币中，因为没有账户的概念，而是引入了UTXO即未花费交易输出。因为没有银行这样的中心化机构的保证，当发生一笔交易时就可能存在着双花的危险：比方说A有一个比特币，然后他同时构造两笔交易T1和T2来花费这1个比特币，其中一个给了B，从B那里买件衣服，一个给了C，从C那里买双鞋。如果不引入某种机制来避免这种情况，那作为数字货币的比特币将没有任何存在的意义。接下来就来分析一下比特币是如何做到防止这种“双花”攻击的。
**正常情况**

 假设A构造了两笔交易T1和T2，将自己价值1btc的UTXO分别转给了B和C，妄图同时从B和C那里获得好处。然后A几乎在同一时间将构造好的这两笔交易广播至网络。

    假设网络中的矿工节点先收到了交易T1，发现这笔交易的资金来源确实没有被花费过，于是将T1加入到自己的内存交易池中等待打包进区块。
    大部分情况下，这个矿工节点会在不久后又收到交易T2，此时因为T2所指向的交易输入与已经加入交易池的T1相同，于是矿工节点会拒绝处理该交易。网络中其他的矿工节点都类似，因此A试图双花的尝试胎死腹中。
**分叉情况**

​    网络中某些节点（可能是离M1近的）先收到了M1打包的区块BLK1，于是用该区块延长自己的区块链，而另外一些节点（邻近M2的）则先收到M2打包的区块BLK2，用该区块延长自己的区块链，于是整个区块链网络中呈现出了不一致的问题。

![img](.\assets\20181030212116498.png)

因此在出现分叉的情况下，通常也只需要等一个区块的确认时间网络节点中的区块链就可以重新一致，在这个例子中，经过一个区块的确认期以后，B最终确认自己收到A的1btc，而因为包含有转账给C的交易T2的区块BLK2位于备用链上，因此无法通过支付验证。A的双花尝试也以失败告终。

    (3) 为什么说比特币需要6个确认才安全
    
    上面提到一般情况下，只要经过1个区块的确认时间基本上就能确保“相对的安全”。而在比特币中，对于很小额的支付，为了提高交易速度，一般也就是等1个区块的确认即可。但是注意这里说的是“相对安全”，对于数额特别大交易，1个区块的确认远远不够。我们考虑上面提到的分叉情况：假设经过1个区块的确认后，B知道了A给他的1btc确实已经位于链上，于是发货给A。此时A及其同伙掌握着很大的一部分算力，A通知其同伙开始使劲挖矿延长备用链（攻击链），当A最终成功的使攻击链的长度（累计工作量）超过当前主链时，会再一次导致网络中的节点切换主链的情况.


4.ETH重放攻击





5.拥有51%的算力：

1.分叉攻击

​	对已经经过6次确认的交易分叉，利⽤51%算⼒将交易记录回滚。

2.封锁交易（Boycott）
	假如攻击者不喜欢某个账户，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。

3.盗币（将他人账户BTC转走）
	这个是**不可能**的，因为其并没有他人账户私钥。如果依仗算⼒强，强⾏将没有签名的转账发布到区块
链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。





### 区块链之分叉是什么鬼？

https://www.jianshu.com/p/a05d9d5155e9

硬分叉，是当比特币协议规则发生改变，旧节点拒绝接受由新节点创造的区块的情况。违反规则的区块将被忽视，矿工会按照他们的规则集，在他们最后见证的区块之后创建区块。

软分叉，与硬分叉不同的是，新的软件版本所定义的新规则与旧版本兼容，但比旧版本更严格。当比特币协议规则发生改变，旧的节点并不会意识到规则是不同的，它们将遵循改变后的规则集，继续接受由新节点创造的区块。矿工们可能会在他们完全没有理解，或者验证过的区块上进行工作。











### **以太坊是什么？如何理解？**

相较于较大多数其他加密货币或区块链技术，以太坊的特点包括下列：

- 智能合约（smart contract）：存储在区块链上的程序，由各节点运行，需要运行程序的人支付手续费给节点的矿工或权益人。

- **代币**（tokens）：智能合约可以创造代币供分布式应用程序使用。分布式应用程序的代币化让用户、投资者以及管理者的利益一致。代币也可以用来进行首次代币发行。

- **叔块**（uncle block）：将因为速度较慢而未及时被收入母链的较短区块链并入，以提升交易量。使用的是有向无环图的相关技术。

- **权益证明**（proof-of-stake）：相较于工作量证明更有效率，可节省大量在挖矿时浪费的电脑资源，并避免特殊应用集成电路造成网络中心化。（测试中）

- 支链（Plasma）：用较小的分支区块链运算，只将最后结果写入主链，可提升供单位时间的工作量。（尚未实现）

- 状态通道（state channels）：原理类似比特币的闪雷网络，可提升交易速度、降低区块链的负担，并提高可扩展性。尚未实现，开发团队包括雷电网络（Raiden Network）和移动性网络（Liquidity Network）。

- 分片（sharding）：减少每个节点所需纪录的数据量，并透过平行运算提升效率（尚未实现）。

- 分布式应用程序：以太坊上的分布式应用程序不会停机，也不能被关掉。

  

**以太坊是目前使用最广泛的支持完备应用开发的公有区块链系统。与比特币相比，以太坊属于区块链 2.0 的范畴，是为了解决比特币网络的一些问题而重新设计的一个区块链系统。**

首先，**它是一个通用的全球性区块链**，也就是说它属于公有链，这一点与比特币是一样的，并且可以用来管理金融和非金融类型的应用。同时，**以太坊也是一个平台和编程语言，包括数字货币以太币（Ether）以及用来构建和发布分布式应用的以太脚本，也就是智能合约编程语言。**

![img](https://pic2.zhimg.com/v2-224509b8b3e2e29d5d8508378decd639_b.jpg)

  而通过智能合约的设计开发，以太坊可以实现各种商业与非商业环境下的复杂逻辑，如众筹系统、数字货币、融资租赁资产管理、多重签名的安全账户、供应链的追踪监控等。通过智能合约的应用，可以将传统的软件系统链化，发挥出更强大的管理能力，相当于隐藏了底层技术的复杂性而让应用开发者更多地专注在应用逻辑及商业逻辑上。

以太坊的模块结构与比特币其实并没有本质的差别，还是那些物件，如区块链账本、共识机制、核心节点、P2P 网络、可编程逻辑等，而本质的特点是智能合约的全面实现，支持了全新的合约编程语言，以及为了运行合约增加了一个以太坊虚拟机。因此我们在理解以太坊的时候，基本上可以参照比特币的结构思路。如果说比特币是利用区块链技术开发的专用计算器，那么以太坊就是利用区块链技术开发的通用计算机。  

**简单地说，以太坊 = 区块链 + 智能合约。**从平台的角度来讲，以太坊类似于苹果的应用商店；从技术角度来讲，以太坊类似于一个区块链操作系统。
我们来看一下以太坊的组成结构：

![img](https://pic3.zhimg.com/v2-9bda0efbe9e29b9a91d47ba515eeba06_b.jpg)

以太坊中的智能合约是运行在虚拟机上的，也就是通常说的 EVM（Ethereum Virtual Machine，以太坊虚拟机）。这是一个智能合约的沙盒，合约存储在以太坊的区块链上，并被编译为以太坊虚拟机字节码，通过虚拟机来运行智能合约。由于这个中间层的存在，以太坊也实现了多种语言的合约代码编译，网络中的每个以太坊节点运行 EVM 实现并执行相同的指令。如果说比特币是二维世界的话，那么以太坊就是三维世界，可以实现无数个不同的二维世界。（以太坊的源码是维护在 GitHub 上的： [https://github.com/ethereum](https://link.zhihu.com/?target=https%3A//github.com/ethereum)）

那么以太币是什么呢？其实和比特币一样，以太币就是以太坊内置的数字货币。在以太坊中，**交易的概念是比较广义的，**因为以太坊并不仅仅支持转账交易这样的合约功能，它的定义如下：在以太坊中，签名的数据包中存储了从外部账户发送的消息。所谓的交易就是一个消息，而这个消息被发送者签名了。

而在以太坊的交易过程中，新增加了Price 与 GasLimit的概念，换句话说就是为了防止在代码中出现意外或有意无限循环或其他计算浪费，每个交易都需要设置一个限制，以限制它的计算总步骤，说白了就是让交易的执行带上成本，每进行一次交易都要支付一定的手续费。Gas 是通过以太坊中合约的执行计算量来决定的，这个计算量可以简单地认为是算力资源的消耗，比如执行一次 SHA3 哈希计算会消耗 20 个 Gas，执行一次普通的转账交易会需要 21000 个 Gas，诸如此类，在以太坊中只要是会消耗计算资源的步骤都有个标价。而这个手续费的最小单位是 wei，然后每 1000 个递进一个单位，如下所示：

通过以上的换算关系，我们可以发现，1ether=1000000000000000000wei，足有 18 个 0。以太坊本身内置支持了以太币，也可以从一个账户往另一个账户转账发送。

**换句话说，如果以太坊是一套完善的银行系统，那么以太币就是其中的钞票。**当然，在很多交易所上，很多人都将交易的单位也称为“以太坊”，这其实并不完全准确，但是也已经是约定俗成了。



### 硬分叉

**区块链的永久性分裂。当没有升级的节点不能验证已升级的节点基于新的共识协议所创建的区块时，硬分叉产生。**

一个概念，就是硬分叉。我们知道，所谓区块链，就是一个个的区块数据，通过区块的哈希值（相当于区块的身份证号）串联起来，如此而形成一个链条般的账本数据。

![img](https://pic4.zhimg.com/v2-c0565907448b65d9d3d5c00dd889147f_b.jpg)

假设在区块增长到 2 号的时候，此时软件升级了，增加了之前版本中不能识别的一些数据结构，会发生什么？在传统的中心化软件体系中，似乎并没有什么问题，这是因为这些中心化的系统，数据存储都是集中的，版本管理也是集中的，如果是重大的升级，完全可以设置为若不更新到最新版就不能进行登录操作，从而确保用户使用的总是正确的版本。

然而区块链先天是去中心的使用方式，一旦有新的软件版本发布后，是不是每个人都会去升级到新版本是很难控制的，这就可能导致如下图所示的问题：在 2 号区块生成的时候发布了新的版本，且新的版本增加了之前版本不能识别的数据结构，此时部分用户升级了新版，部分用户还没有升级，这些新旧版本的软件仍然在各自不停的挖矿、验证、打包区块，一段时间过后就会变成这样：

![img](https://pic1.zhimg.com/v2-4b97466e1f87229c6655c38f1fcf2168_b.jpg)

那什么是硬分叉呢？当版本变动没达到某个程度，老版本的节点就还可以认识新版本的节点，这叫软分叉；而反之，当老版本的节点已经没办法认识分叉后新出现的节点，那么这就是一次硬分叉了。硬分叉的结果就是走出两条链，各自分道扬镳，当然，最近大家热衷的“分糖果”也是由此而来的。
一个事件，是什么呢？这件事情就是2016年6月的TheDAS被攻击事件。区块链业界最大的众筹项目TheDAO遭到黑客攻击,导致300多万以太币资产被分离出TheDAO 资产池，如果按照今天的数据，那么大概相当于20亿美元。
要知道，数字货币是匿名性质的。银行丢了20亿美元现金，想找回来的可能性几乎是100%，可在区块链世界里就是大海捞针。所以这个时候，以太坊的创始人V神出来说话了：以太坊进行硬分叉，作出一个向后不兼容的改变，让所有的以太币（包括被移动的）回归原处，而不接受此改变的区块链则成为古典以太坊（Ethereum Classic）。这是第一次有主流区块链为了补偿投资人，而透过分叉来更动交易记录。

在这次分叉之后，造成了在两个区块链之间进行重放攻击的可能，加上其他网络攻击，让以太坊和古典以太坊又各自进行了数次分叉来避免攻击。



### 以太坊的几次分叉

第一次分叉调整了未来挖矿的难度，确保未来的用户会有转换至权益证明的动机。当前第五个分叉正在开发中。

**第二次分叉：家园**

2016年春季进行了第二次分叉，发布了第一个稳定版本，称作“家园”（Homestead）。

**第三次分叉：DAO和区块链分叉**

2016年六月，以太坊上的一个去中心化自治组织 The DAO 被骇，造成市值五千万美元的以太币被移动到只有该黑客可以控制的“分身DAO”。因为程序不允许黑客立即提取这些以太币，以太坊用户有时间讨论如何处理此事，考虑的方案包括取回以太币和关闭DAO，而DAO去中心化的本质也表示没有中央权力可以立即反应，而需要用户的共识。最后在2016年7月20日，以太坊进行硬分叉，作出一个向后不兼容的改变，让所有的以太币（包括被移动的）回归原处，而不接受此改变的区块链则成为古典以太坊（Ethereum Classic）。这是第一次有主流区块链为了补偿投资人，而透过分叉来更动交易记录。

在这次分叉之后，造成了在两个区块链之间进行重放攻击的可能，加上其他网络攻击，让以太坊和古典以太坊又各自进行了数次分叉来避免攻击。

**第四次分叉：**减重和防DDoS2016年11月底进行了第四次的分叉。这次分叉为区块链减重（de-bloat），并加入一些避免网络攻击的设计。因为沟通疏失，这次分叉短暂造成以太坊的两个主要客户端程序 Parity 和 Geth 失去共识而产生意外的分叉，但问题在数小时内即被找出并修正。











### 关于 ETH Merge、ETC 迁徙的技术细节和背后原因

https://web3caff.com/zh/archives/24566

Eth 从 POW 到 POS 的转变是不是一种软分叉呢？（第一次分叉？   后续2022.9.5 完全切换为POS

具体看后面 **ETH挖矿算法篇2**



### **比特币网络中轻节点从何而来？链中是轻节点多还是全节点多？**

未知答案

轻节点技术【https://zhuanlan.zhihu.com/p/342784693】







### 为什么需要Merkle proof?

Merkle Tree也称为Hash Tree，由Ralph Merkle于1979年提出并命名，是基于Hash的数据结构，它是一种树结构，每个叶节点是数据块的Hash，每个非叶节点是其子节点的Hash。Merkle Tree可以高效和安全地实现较大的数据内容验证，它是Hash List和Hash Chain的泛化。Merkle Tree通常实现为二叉树，如下图所示。但Merkle Tree也可以实现节点包含多个子节点的。

用途：Mekle Tree被用于分布式系统中，可用于验证计算机之间存储，处理和传输的任何类型数据，确保在P2P网络中收到的数据块没有被破坏或者篡改，甚至有没有发送假数据块。Merkle tree已经被用于以下场景：

**为什么不直接将数据块拼成一个大块在计算Hash**？

Merkle Tree：Hash List可认为是一种树高为2的N叉Merkle Tree，实现原理与Hash List类似，将数据分割成小的Block，并计算数据块的Hash，将相邻两个Hash合并后再计算出父Hash，Hash(Hash(DataBlock1) | Hash(DataBlock2))，再将新的相邻的两个父Hash值进行Hash，生成更上层的Hash，最后会汇聚到树的根节点，称为Merkle Root。但是Merkle Tree最重要的好处是可以单独取出Hash树的一个分支对数据进行验证，而不用计算整个Merkle Tree。

**Second Preimage攻击 **(给定固定消息m1，找到其他消息m2，以便hash(m2)= hash(m1)。

​	Merkle Tree的根并不表示树的深度，这将导致second-preimage攻击，攻击者可以创建出一个具有相同Merkle Root的的新Merkle Tree分支。一个简单的解决方法在Certificate Transparency中定义：

​	计算叶节点Hash时，在数据前加0x00，在计算内部节点Hash时，在数据前加0x01，限制Hash树的大小是一些正式安全验证的先决条件。一些实现在Hash前使加树深前缀来限制树的深度，在获取Hash链时，每一步都要减少前缀并且到达叶节点时仍为正才被认为有效。

**Merkle Proof**         通过Merkle Root证明给定的数据块或者交易是否在节点上

Merkle Proof包括一个数据块，Merkle Root，以及从数据块到根路径上的所有Hash组成的"分支"。阅读证明者可以验证给定数据块的Hash(至少对于当前分支)以及到Root路径上的所有节点的Hash的一致性，并最终验证给定的数据块是否真正在树中的节点上。

**Bitcoin中的Merkle证明**

这样做的好处正如中本聪描述的"simplified payment verification"：“light client(轻客户端)”只下载链中区块头的80byte数据块，而不是下载所有交易和所有区块，每个块仅包含以下五个元素：

如果"轻客户端"想要确认交易的状态，只需简单发起一个Merkle proof证明这个特定交易在Merkle tree上，并且树的Merkle root在主链的区块头中。

虽然这样做可以让区块链持续很久，但是Bitcoin "轻客户端"也有其局限性。其中一个限制是，虽然可以证明包含的交易状态，但是无法证明当前的状态(例如：持有的数字资产，名称注册，金融合约的状态等)。用户当前有多少Bitcoin？Bitcoin轻客户端使用一个协议，该协议涉及查询多个节点，并确信其中至少有一个节点会返回通知，包含你的地址支出的任何特定交易，虽然可以满足Bitcoin应用，但对于更加复杂的应用还远远不够。一笔交易影响的确切性取决于前几笔交易，而前一笔交易又依赖更前面的交易，最终不得不验证整条链上的每一笔交易。为了解决这个问题，Ethereum使用更先进的Merkle tree概念。

**Ethereum中的Merkle证明**

Ethereum区块头不是包含一棵Merkle tree，而是包含三颗树代表三种不同类型：交易、收据和状态。

这允许Ethereum使用更加先进的**轻客户端协议让轻客户端**很容易地实现以下不同查询类型的验证：

- 当前交易是否包含在特定区块中？
- 告诉我过去30天内该地址发出X类事件(例如：一个达到目标的众筹合约)的所有情况。
- 我账户目前的余额？
- 当前帐户是否存在？
- 假设在合约中运行此交易将输出什么结果？



​	其中，第一条由(交易)事务树处理；第三条和第四条由状态树处理，第二条由收据树处理。前四条计算相对简单；服务器只需简单找到对象，获取Merkle分支(从对象到Merkle root的Hash列表）并返回给轻客户端。

第五条也由状态树处理，但计算方式更加复杂。我们需要构造一个所谓的Merkle状态转换证明(Merkle state transition proof)。从本质上讲，状态转换证明中声明"**如果你在具有根S的状态树上运行交易T，结果将是具有根S‘，日志L和输出为O的状态"**（由于每一笔交易都是一个函数调用，所以“输出”只作为Ethereum中的一个概念存在，理论上它并不是必须的）。

​	**为了计算Proof，服务器在本地创建一个假的区块，将状态设置为S，并在应用时充当轻客户端。也就是说，如果应用交易的过程要求客户端确定帐户余额，则轻客户端会发起一个余额查询请求。如果轻客户端需要检查特定合约中存储的特定条目，也同样发起查询请求。服务端正确地"responds"自己所有查询，但跟踪它发回的所有数据。然后，服务端将所有这些作为证明的请求的合并数据发送给客户端。最后客户端执行完全相同的过程，但使用服务端提供的证明做为数据库，如果客户端计算的结果与服务端声明的结果一致，则客户端接受此证明。**

****

**Particia Trees**

最简单的Merkle tree是一棵二叉树。然而，Ethereum中使用的树更复杂- 称为"Merkle Patricia tree"，可以查询Ethereum官方相关文档。

对于事务树，使用二叉Merkle树来是非常好的数据结构，因为树被一旦被创建一次会永久存在，所以编辑树所花费的时间已经不重要了。

然而，对于状态树，情况会更复杂。Ethereum中状态基本上是由键值对组成，其中键是地址，值是帐户声明，对于每个帐户列出每个帐户余额，随机数据，代码和存储(存储本身也是一棵树)。

同时，与事务历史不同，状态需要频繁被更新。账户余额和随机数也经常变化，新帐户频繁创建，存储的key也经常会增删改操作。因此，在做增删改操作后，我们期望一种快速计算新kerkle树根的数据结构，而不是重新计算整棵树。这种结构也要有两个理想的次要属性：

- **树的深度是有限的**，即使攻击者故意制作交易以使树尽可能深。否则，攻击者可以通过操纵树的深度来执行拒绝服务攻击，使得每个更新变得非常缓慢。
- 树的根只取决于数据，而不取决于更新的顺序。以不同的顺序进行更新甚至重新计算树不应该更改根。

简单来说，Patricia tree可能是我们实现所有这些属性最接近的树。它的工作原理最简单的解释是value存储在key中，key被编码到搜索树的路径中。每个节点有16个子节点，因此路径由十六进制编码决定：例如，key为dog的十六进制编码是6 4 6 15 6 7，所以从根开始，下到第6个子节点，然后到第4个，再进行其余四步，直到最后叶节点。在实践中，当树比较稀疏时，可以根据情况进行一些额外优化，但是要遵循这些基本原则。

**总结**

Merkle tree使用基于Hash的密码学来确保数据传输的完整性，已经用在许多分布式文件系统，P2P网络，证书验证，可信计算，NoSQL和区块链等方面。Merkle tree中允许取出树中一个分支来验证数据，而避免计算整棵Hash树，除了加带检索效率，也确保了使用Merkle tree的系统的可持续性。本文主要简介了Merkle Tree基本原理和以及在区域链中的使用，**对于Merkle tree更深层次的理解**，可以阅读一些开源代码(如**Ethereum和Hyperledger**等)的实现。









### BTC回顾问答篇

1.  转账交易时候，如果接收者不在线(没有连在比特币网络上)怎么办？
   转账交易只需要在区块链上记录，将某账户比特币转到另一账户，而接收方是否在线并无影响。

2. 假设某全节点收到某个转账交易，会不会有可能转账交易中收款人地址该全节点从未听过。
   可能，因为比特币账户只需要本地产生即可。只有该账户第一次收到钱时，其他节点才能知道该节点的存在。
   如果账户私钥丢失怎么办？
   没有办法。因为比特币是去中心化货币，没有第三方中心机构可以重置密码，所以账户上的钱也就变成了死钱。
   通过加密货币交易所(中心化机构)，一般需要提供身份证明，如果忘记私钥可以找交易所申请追回私钥。但目前这类货币的交易所，尚且处于缺少监管的状态，并不一定具有可信力。而且，其本身仅起到“中介”作用，与该提问的回答“私钥丢失无法追回里面的比特币”并不冲突。
   在历史上，有很多次交易所被黑客攻击偷走大量加密货币的事情，其中最著名的为Mt. GOX（中文译为：门头沟）事件。该交易所曾经为全球最大比特币交易所，交易量占到全球比特币交易量的70%左右，设于日本。后来由于被攻击丢失大量比特币，导致交易所破产，其CEO被判刑入狱。
   此外，也有交易所监守自盗，工作人员卷款跑路(有点类似 rm -rf */ 删库跑路系列)。

3. 私钥泄露怎么办？
   尽快将剩余BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。
   BTC系统中账户便是公私钥对，密码就是私钥，无法更改。

4. 转账写错地址怎么办？
   没有办法，只能自认倒霉，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。当然，比特币系统中UTXO会永久保存该交易，记录该并不存在的地址。因此，对全节点来说，这是不友好的。
   之前在BTC脚本中介绍了OP_RETURN指令，我们提到，这种方法为普通用户提供了一个向比特币网络中写入想要一直保存的内容。但OP_RETURN执行结果是无条件返回错误，而交易返回错误，区块又怎么会包含它？区块链又如何会接收这个区块？

   > 思想1：特殊机制，该脚本即使返回错误，仍然写入区块链。（实际并不是）
   > 思想2：即使返回失败，仍然写入区块链，只是具体处理时候不计算其即可。(恶意节点大量抛出失败交易，攻击区块链怎么办？上一篇中提到，每秒平均只能处理7笔交易)

实际上，这里需要想清楚一个细节（这里我第二遍回看视频的时候，碰到这个问题仍然忘记了为什么，真的为自己的愚蠢留下泪水。55555....） 要想清楚，OP_RETURN是写在哪里的。OP_RETURN实际写在当前交易的输出脚本中，而验证交易合法性时，使用的当前交易的输入脚本和前一个交易(币来源的交易)的输出脚本进行验证。也就是说，验证当前交易合法性时，并不会执行该语句。（是不是感觉很妙呀？？？）只有在有人想花这笔钱时候，才会执行该语句。

5. BTC系统挖矿，会不会有矿工“偷”答案？例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。
   实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，如果要偷答案，需要修改该收款地址，而地址改变，铸币交易内容也发生改变，从而引发Merkle Tree根哈希值改变。从而导致原本的nonce作废。也就是说，不可能会“偷”答案。
6. 交易费是交易者为了自己交易可以上链而给出的“小费”，那么如何得知哪个矿工可以挖到矿？
   事先无需知道谁会挖到矿，交易中总输入和总输出差额就是交易费。哪个矿工挖到矿，在打包交易时，可以将这些交易费收集起来作为自己获得的交易费。





